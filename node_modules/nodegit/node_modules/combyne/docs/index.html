<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Index</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Index</h1>

    


    


    <h3> </h3>









    




    <section>
        <article><p><img align="left" src="http://dl.dropboxusercontent.com/u/79007/combyne.png"></p>
<p><strong>Stable: 0.5.1</strong></p>
<p><a href="https://travis-ci.org/tbranyen/combyne"><img src="https://travis-ci.org/tbranyen/combyne.png?branch=master" alt="Build Status"></a>
<a href="https://coveralls.io/r/tbranyen/combyne?branch=master"><img src="https://coveralls.io/repos/tbranyen/combyne/badge.png?branch=master" alt="Coverage Status"></a>
<a href="https://codeclimate.com/github/tbranyen/combyne"><img src="https://codeclimate.com/github/tbranyen/combyne.png" alt="Code Climahttps://codeclimate.com/github/tbranyen/combyne/badgeste"></a></p>
<p>No dependencies.  Can be loaded as a browser global, AMD module, and Node
module.  Works with Browserify.  Can be installed via NPM or Bower.</p>
<p>Combyne works great with:</p>
<ul>
<li><a href="https://github.com/tbranyen/combynexpress">Express</a></li>
<li><a href="https://github.com/chesles/combynify">Browserify</a></li>
<li><a href="https://github.com/tbranyen/combyne-amd-loader">AMD</a></li>
</ul>
<h2>Install.</h2><p>Node:</p>
<pre class="prettyprint source lang-bash"><code>npm install combyne</code></pre><p>Bower:</p>
<pre class="prettyprint source lang-bash"><code>bower install combyne</code></pre><h2>Getting started.</h2><h3>Node.</h3><p>Require in your source:</p>
<pre class="prettyprint source lang-javascript"><code>var combyne = require(&quot;combyne&quot;);</code></pre><h3>AMD.</h3><pre class="prettyprint source lang-javascript"><code>// Configure the path if necessary.
require({
  paths: {
    combyne: &quot;path/to/combyne&quot;
  }
});

// Use in a module.
define([&quot;combyne&quot;], function(combyne) {});</code></pre><p>There is also an AMD plugin for easier consumption and building:</p>
<p>https://github.com/tbranyen/combyne-amd-loader</p>
<h3>Browserify.</h3><p><a href="https://github.com/chesles/combynify">combynify</a> is a
<a href="https://github.com/substack/browserify">browserify</a> transform plugin to
pre-compile combyne templates.</p>
<p>In your code:</p>
<pre class="prettyprint source lang-javascript"><code>var template = require(&quot;./template.combyne&quot;);
var data = { ... }

template.render(data)</code></pre><p>Install combynify and browserify it:</p>
<pre class="prettyprint source lang-bash"><code>npm install --save-dev combynify
browserify -t combynify main.js > bundle.js</code></pre><p>Once the template is precompiled, there is no dependency on the combyne
engine.</p>
<h3>Browser global.</h3><p><a href="https://github.com/tbranyen/combyne/releases">Include the latest stable</a>
in your markup:</p>
<pre class="prettyprint source lang-html"><code>&lt;script src=&quot;path/to/dist/combyne.js&quot;>&lt;/script></code></pre><h4>Compatibility.</h4><p>Combyne is written in ES5 and contains polyfills to provide support back to IE</p>
<ol>
<li>These polyfills are omitted in the <strong>dist/combyne.js</strong> file, but exist in
the <strong>dist/combyne.legacy.js</strong> file.  Use this if you are developing/testing
with older IE.</li>
</ol>
<p><a href="https://saucelabs.com/u/combyne"><img src="https://saucelabs.com/browser-matrix/combyne.svg" alt="Selenium Test Status"></a></p>
<h2>Basic usage.</h2><pre class="prettyprint source lang-javascript"><code>var tmpl = combyne(&quot;hello {{msg}}!&quot;);
tmpl.render({ msg: &quot;world&quot; });

// => hello world!</code></pre><h2>Features.</h2><p>Combyne works by parsing your template into an AST.  This provides mechanisms
for intelligent compilation and optimization.  The template is converted to
JavaScript and invoked upon calling render with data.</p>
<h3>Security.</h3><p>By default all templates are encoded to avoid possible issues arising from XSS
attacks.  This is specifically applied to properties and you can avoid this by
using the raw property style: <code>{{{ value }}}</code>.  This is very similar to
Mustache.</p>
<p>While using this template engine in the browser, it is important to note that
you should not trust unknown values to render unencoded.  The recommendation is
to forget it exists while writing templates in the browser, unless you know
what you're doing and have a valid use case.</p>
<p>View this <a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting">XSS (Cross Site Scripting) Prevention Cheat Sheet</a>_Prevention_Cheat_Sheet) for more information.</p>
<h3>Comments.</h3><p>Comments are useful for ignoring anything between the open and close.  They can
be nested.</p>
<pre class="prettyprint source lang-javascript"><code>var tmpl = combyne(&quot;test {%-- not parsed --%}&quot;);
tmpl.render();

// => test</code></pre><h3>Custom delimiters.</h3><p>If you are not happy with the default Mustache-like syntax, you can trivially
change the delimiters to suit your needs.  You may only change the delimiters
at a global level, because templates are compiled immediately after invoking
the <code>combyne</code> function.</p>
<pre class="prettyprint source lang-javascript"><code>// This sets the delimiters, and applies to all templates.
combyne.settings.delimiters = {
  START_PROP: &quot;[[&quot;,
  END_PROP: &quot;]]&quot;
};

var tmpl = combyne(&quot;[[msg]]&quot;, { msg: &quot;hello world&quot; });

tmpl.render();
// => hello world</code></pre><p>Defaults:</p>
<pre class="prettyprint source lang-javascript"><code>START_RAW:  &quot;{{{&quot;
END_RAW:    &quot;}}}&quot;
START_PROP: &quot;{{&quot;
END_PROP:   &quot;}}&quot;
START_EXPR: &quot;{%&quot;
END_EXPR:   &quot;%}&quot;
COMMENT:    &quot;--&quot;
FILTER:     &quot;|&quot;</code></pre><h3>Template variables.</h3><pre class="prettyprint source lang-javascript"><code>var template = &quot;{{foo}}&quot;;
var context = { foo: &quot;hello&quot; };

var tmpl = combyne(template);

var output = tmpl.render(context);
/// output == &quot;hello&quot;</code></pre><p>Variables can be literal values, functions, or even objects.</p>
<h4>Passing arguments to a function.</h4><pre class="prettyprint source lang-javascript"><code>var template = &quot;{{toUpper 'hi'}}&quot;;
var context = { toUpper: function(val) { return val.toUpperCase(); } };

var tmpl = combyne(template);

var output = tmpl.render(context);
/// output == &quot;HI&quot;</code></pre><h3>Using filters on variables.</h3><pre class="prettyprint source lang-javascript"><code>var template = &quot;{{foo|reverse}}&quot;;
var context = { foo: &quot;hello&quot; };

var tmpl = combyne(template);

tmpl.registerFilter(&quot;reverse&quot;, function(val) {
  return val.split(&quot;&quot;).reverse().join(&quot;&quot;);
});

var output = tmpl.render(context);
/// output == &quot;olleh&quot;</code></pre><h4>Passing arguments to filters.</h4><p>You may find that the property value is not enough information for the filter
function, in which case you can send additional arguments.</p>
<pre class="prettyprint source lang-javascript"><code>var tmpl = combyne(&quot;{{ code|highlight 'javascript' }}&quot;);

tmpl.registerFilter(&quot;highlight&quot;, function(code, language) {
  // Magic highlight function that takes code and language.
  return highlight(code, language);
});</code></pre><h4>Chaining filters on variables.</h4><pre class="prettyprint source lang-javascript"><code>var template = &quot;{{foo|reverse|toUpper}}&quot;;
var context = { foo: &quot;hello&quot; };

var tmpl = combyne(template);

tmpl.registerFilter(&quot;reverse&quot;, function(val) {
  return val.split(&quot;&quot;).reverse().join(&quot;&quot;);
});

tmpl.registerFilter(&quot;toUpper&quot;, function(val) {
  return val.toUpperCase();
});

var output = tmpl.render(context);
/// output == &quot;OLLEH&quot;</code></pre><h3>Conditionals.</h3><p>Instead of being <em>logic-less</em>, <code>combyne</code> doesn't make any assumptions and
allows you to do things like <code>if/elsif/else</code> with simple conditionals,
such as <code>if something == somethingElse</code> or <code>if not something</code>.  All data 
types will be coerced to Strings except for Numbers.</p>
<pre class="prettyprint source lang-javascript"><code>var template = &quot;{%if not foo%}why not?{%endif%}&quot;;
var context = { foo: false };

var tmpl = combyne(template);

var output = tmpl.render(context);
/// output == &quot;why not?&quot;</code></pre><p>or a more complicated example...</p>
<pre class="prettyprint source lang-javascript"><code>var template = &quot;{%if foo == 'hello'%}Hi!{%else%}bye...{%endif%}&quot;;
var context = { foo: &quot;hello&quot; };

var tmpl = combyne(template);

var output = tmpl.render(context);
/// output == &quot;Hi!&quot;</code></pre><p>elsif is also supported:</p>
<pre class="prettyprint source lang-javascript"><code>var template = &quot;{%if foo == ''%}goodbye!{%elsif foo == 'hello'%}hello!{%endif%}&quot;;
var context = { foo: &quot;hello&quot; };

var tmpl = combyne(template);

var output = tmpl.render(context);
/// output == &quot;hello!&quot;</code></pre><h3>Iterating arrays.</h3><p><em>Also works on array-like objects: arguments and NodeList.</em></p>
<pre class="prettyprint source lang-javascript"><code>var template = &quot;{%each foo%}{{.}} {%endeach%}&quot;;
var context = { foo: [1,2,3,4] };

var tmpl = combyne(template);

var output = tmpl.render(context);
/// output == &quot;1 2 3 4 &quot;</code></pre><h4>Iterating an array of objects shorthand.</h4><p>If you pass an array of objects to Combyne, you may iterate it via a shorthand:</p>
<pre class="prettyprint source lang-javascript"><code>var template = &quot;{%each%}{{foo}} {%endeach%}&quot;;
var context = [{ foo: 1 }, { foo: 2 }, { foo: 3 }, { foo: 4 }];

var tmpl = combyne(template);

var output = tmpl.render(context);
/// output == &quot;1 2 3 4 &quot;</code></pre><h4>Change the iterated identifer within loops.</h4><pre class="prettyprint source lang-javascript"><code>var template = &quot;{%each arr as val%}{{val}}{%endeach%}&quot;;
var context = { arr: [1,2,3] };

var tmpl = combyne(template);

var output = tmpl.render(context);
/// output = &quot;123&quot;</code></pre><h3>Iterating objects.</h3><pre class="prettyprint source lang-javascript"><code>var template = &quot;{%each fruits as val key%}the {{key}} is {{val}}{%endeach%}&quot;;
var context = {
  fruits: {
    apple: &quot;green&quot;
  }
};

var tmpl = combyne(template);

var output = tmpl.render(context);
/// output == &quot;the apple is green&quot;</code></pre><h3>Partials.</h3><pre class="prettyprint source lang-javascript"><code>var template = &quot;{{foo}} {%partial bar%}&quot;;
var context = { foo: &quot;hello&quot; };

var tmpl = combyne(template);

tmpl.registerPartial(&quot;bar&quot;, combyne(&quot;{{name}}&quot;, {
  name: &quot;john&quot;
}));

var output = tmpl.render(context);
/// output == &quot;hello john&quot;</code></pre><h4>Pass template data to partial.</h4><p>If you need to pass the template's data to the partial, simply use the magic
operator <code>.</code>.</p>
<pre class="prettyprint source lang-javascript"><code>var template = &quot;{{foo}} {%partial bar .%}&quot;;
var context = { foo: &quot;hello&quot;, name: &quot;carl&quot; };

var tmpl = combyne(template);

tmpl.registerPartial(&quot;bar&quot;, combyne(&quot;{{name}}&quot;));

var output = tmpl.render(context);
/// output == &quot;hello carl&quot;</code></pre><h4>Template inheritance.</h4><p>When using a framework that handles rendering for you and you wish to inject
your template into a different template (maybe a layout) in a given region
you can express this through template inheritance expressions.</p>
<p>Illustrated below is a typical use case for this feature:</p>
<pre class="prettyprint source lang-javascript"><code>var template = &quot;{%extend layout as content%}&lt;h1>{{header}}&lt;/h1>{%endextend%}&quot;;
var context = { header: &quot;Home page&quot; };

var page = combyne(template);

// Register the layout template into the page template.
page.registerPartial(&quot;layout&quot;, combyne(&quot;&lt;body>{%partial content%}&lt;/body>&quot;));

var output = page.render(context);
/// output == &quot;&lt;body>&lt;h1>Home page&lt;/h1>&lt;/body>&quot;</code></pre><p>The context object you pass at the <code>page.render</code> line will be propagated to
the partial template.  This means that you can optionally pass a nested object
structure like:</p>
<pre class="prettyprint source lang-javascript"><code>var context = {
  header: &quot;My site&quot;,

  page: {
    header: &quot;Home page&quot;
  }
};

// Pass the page object to the page template, restricting what it has access
// to.
var layout = &quot;&lt;title>{{header}}&lt;/title>&lt;body>{%partial content page%}&lt;/body>&quot;;

// Register it in the partial. 
page.registerPartial(&quot;layout&quot;, combyne(layout));

var output = page.render(context);
/// output == &quot;&lt;title>My site&lt;/title>&lt;body>&lt;h1>Home page&lt;/h1>&lt;/body>&quot;</code></pre><h2>Unit tests.</h2><p>There are many ways to run the unit tests as this library can operate in
various environments.</p>
<h3>Browser</h3><p>Open test/index.html in your web browser.</p>
<h3>Node</h3><p>Run the tests inside the Node runtime and within PhantomJS:</p>
<pre class="prettyprint source lang-bash"><code>grunt test</code></pre><p>This will run the tests against the AMD source, the built modern
dist/combyne.js, and the built legacy dist/combyne.legacy.js files.</p>
<h3>Continuous testing</h3><p>To keep the PhantomJS tests running continuously, run:</p>
<pre class="prettyprint source lang-bash"><code>grunt karma:watch</code></pre><p>The tests will automatically run whenever files change.</p>
<h4>Code coverage</h4><p>If you run the tests through Karma, a test/coverage directory will be created
containing folders that correspond with the environment where the tests were
run.</p>
<p>If you are running the defaults you should see something that looks like:</p>
<pre class="prettyprint source lang-unicode"><code>.
└── coverage
    ├── Chrome 33.0.1750 (Linux)
    └── PhantomJS 1.9.7 (Linux)</code></pre><p>Inside PhantomJS contains the HTML output that can be opened in a browser to
inspect the source coverage from running the tests.</p></article>
    </section>






</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-compiler.html">compiler</a></li><li><a href="module-grammar.html">grammar</a></li><li><a href="module-index.html">index</a></li><li><a href="encode.html">shared/encode</a></li><li><a href="register_filter.html">shared/register_filter</a></li><li><a href="register_partial.html">shared/register_partial</a></li><li><a href="module-tokenizer.html">tokenizer</a></li><li><a href="module-tree.html">tree</a></li><li><a href="create_object.html">utils/create_object</a></li><li><a href="defaults.html">utils/defaults</a></li><li><a href="escape_delimiter.html">utils/escape_delimiter</a></li><li><a href="map_.html">utils/map</a></li><li><a href="type.html">utils/type</a></li></ul><h3>Classes</h3><ul><li><a href="module-compiler.Compiler.html">Compiler</a></li><li><a href="module-grammar.Grammar.html">Grammar</a></li><li><a href="module-index.Combyne.html">Combyne</a></li><li><a href="module-tokenizer.Tokenizer.html">Tokenizer</a></li><li><a href="module-tree.Tree.html">Tree</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha9</a> on Mon Sep 15 2014 21:36:09 GMT-0400 (EDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>